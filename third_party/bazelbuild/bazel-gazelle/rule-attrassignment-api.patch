commit e240ddb5c215fd4b1952208363e1bde073ed4865
Author: Paul Johnston <paul.johnston02@sap.com>
Date:   Thu Oct 20 17:41:25 2022 -0600

    add r.AttrAssignment

diff --git a/rule/rule.go b/rule/rule.go
index 1eb72fb..e33d1fa 100644
--- a/rule/rule.go
+++ b/rule/rule.go
@@ -411,6 +411,16 @@ func (f *File) Save(path string) error {
 	return ioutil.WriteFile(path, f.Content, 0o666)
 }
 
+// AttrAssignment returns the value of the named *build.AssignExpr. nil is
+// returned when the attribute is not set.
+func (r *Rule) AttrAssignment(key string) *bzl.AssignExpr {
+	attr, ok := r.attrs[key]
+	if !ok {
+		return nil
+	}
+	return attr
+}
+
 // HasDefaultVisibility returns whether the File contains a "package" rule with
 // a "default_visibility" attribute. Rules generated by Gazelle should not
 // have their own visibility attributes if this is the case.
diff --git a/rule/rule_test.go b/rule/rule_test.go
index 3b6992e..7016751 100644
--- a/rule/rule_test.go
+++ b/rule/rule_test.go
@@ -393,6 +393,141 @@ func TestShouldKeepExpr(t *testing.T) {
 	}
 }
 
+// TestRuleExprAPI demonstrates the exprs that are accessible via the Rule API.
+// It uses the ShouldKeep utility for convenience but is not necessarily a test
+// of the ShouldKeep API per se.
+func TestRuleExprAPI(t *testing.T) {
+	for desc, tc := range map[string]struct {
+		desc, src  string
+		shouldKeep func(t *testing.T, r *Rule) bool
+		want       bool
+	}{
+		"rule comments": {
+			src: `
+# keep
+rule(name = "test")
+`,
+			shouldKeep: func(t *testing.T, r *Rule) bool {
+				t.Log("rule should keep?:", r.Comments())
+				return r.ShouldKeep()
+			},
+			want: true,
+		},
+		"list item suffix": {
+			src: `
+rule(
+    name = "test",
+    deps = [
+        "a",  # keep
+    ],
+)
+`,
+			shouldKeep: func(t *testing.T, r *Rule) bool {
+				list, ok := r.Attr("deps").(*bzl.ListExpr)
+				if !ok {
+					t.Fatalf("want ListExpr, got %T", list)
+				}
+				str, ok := list.List[0].(*bzl.StringExpr)
+				if !ok {
+					t.Fatalf("want StringExpr, got %T", str)
+				}
+				return ShouldKeep(str)
+			},
+			want: true,
+		},
+		"list item before": {
+			src: `
+rule(
+    name = "test",
+    deps = [
+		# keep
+        "a",
+    ],
+)
+`,
+			shouldKeep: func(t *testing.T, r *Rule) bool {
+				list, ok := r.Attr("deps").(*bzl.ListExpr)
+				if !ok {
+					t.Fatalf("want ListExpr, got %T", list)
+				}
+				str, ok := list.List[0].(*bzl.StringExpr)
+				if !ok {
+					t.Fatalf("want StringExpr, got %T", str)
+				}
+				return ShouldKeep(str)
+			},
+			want: true,
+		},
+		"list before": {
+			src: `
+rule(
+    name = "test",
+    deps =
+		# keep
+		[
+			"a",
+		],
+)
+`,
+			shouldKeep: func(t *testing.T, r *Rule) bool {
+				list, ok := r.Attr("deps").(*bzl.ListExpr)
+				if !ok {
+					t.Fatalf("want ListExpr, got %T", list)
+				}
+				return ShouldKeep(list)
+			},
+			want: true,
+		},
+		"list suffix - not possible?": {
+			src: `
+rule(
+    name = "test",
+	deps = ["a"] # keep
+)
+`,
+			shouldKeep: func(t *testing.T, r *Rule) bool {
+				list, ok := r.Attr("deps").(*bzl.ListExpr)
+				if !ok {
+					t.Fatalf("want ListExpr, got %T", list)
+				}
+				return ShouldKeep(list)
+			},
+			want: false,
+		},
+		"assign expr": {
+			src: `
+rule(
+    name = "test",
+	# keep
+	deps = ["a"]
+)
+`,
+			shouldKeep: func(t *testing.T, r *Rule) bool {
+				assign := r.AttrAssignment("deps")
+				return ShouldKeep(assign)
+			},
+			want: true,
+		},
+	} {
+		t.Run(desc, func(t *testing.T) {
+			file, err := LoadData("", "", []byte(tc.src))
+			if err != nil {
+				t.Fatal(err)
+			}
+			if len(file.Rules) != 1 {
+				t.Fatal("test case should decare one rule")
+			}
+			var got bool
+			if tc.shouldKeep != nil {
+				got = tc.shouldKeep(t, file.Rules[0])
+			}
+			if got != tc.want {
+				t.Errorf("got %v; want %v", got, tc.want)
+			}
+		})
+	}
+}
+
 func TestInternalVisibility(t *testing.T) {
 	tests := []struct {
 		rel      string
