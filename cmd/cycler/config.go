package main

import (
	"bufio"
	"encoding/csv"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/label"

	"github.com/stackb/scala-gazelle/pkg/index"
)

// config represents command line args and static data that does not change over
// the course of the program lifetime.
type config struct {
	// shellFile is a filesystem path to a bash.
	shellFile string
	// scriptFile is a filesystem path to a runner script which should run bazel.
	scriptFile string
	// scriptArgs are optional args to the script.
	scriptArgs string
	// importsFile is a filesystem path to the imports.csv file (mapping between imports and labels).
	importsFile string
	// sourceIndexFile is the filesystem path the scala_source_index.json (generated by parsing all the sources)
	sourceIndexFile string
	// buildEventsFile is a filesystem path to the --build_events_json_file
	buildEventsFile string
	// buildozerScriptFile is a filesystem path to the a config file that buildozer can consume
	buildozerScriptFile string
	// symbolMappingsFile is a filesystem path to a JSON object for the symbol mappings
	symbolMappingsFile string
	// resolveHintFile is an optional file that can be used to provide hints to the resolver.  it is a JSON object of of the form { "FILENAME:NOT_FOUND_SYMBOL": "ACTUAL_IMPORT"}.
	resolveHintFile string
	// labelMappingsFile is a filesystem path to a JSON object for the symbol mappings
	labelMappingsFile string
	// stateFile is the persisted state of this application
	stateFile string
	// imports are the parsed list of imports
	imports map[string]label.Label
	// iterations is the number of iterations to run
	iterations int
	// symbolMappings are a mapping from one type to another.
	symbolMappings map[string]string
	// labelMappings are a mapping from one label to another.  This is needed
	// when bazel reports the error from the actual label //app:scala, but the
	// BUILD file uses a macro like 'scala_image(name="app")' that is actually
	// in the BUILD file.
	labelMappings map[label.Label]label.Label
	// files is a mapping from the filename to its parsed index
	files map[string]*index.ScalaFileSpec
	// resolveHintMap is the parsed hint map
	hintMap map[string][]*resolveHint
	// buildozerCommand is a list of buildozerCommands
	buildozerCommands []string
	// state object
	state *State
}

func newConfig(fs *flag.FlagSet) *config {
	c := &config{
		imports:        make(map[string]label.Label),
		files:          make(map[string]*index.ScalaFileSpec),
		symbolMappings: make(map[string]string),
		labelMappings:  make(map[label.Label]label.Label),
		hintMap:        make(map[string][]*resolveHint),
	}

	fs.StringVar(&c.shellFile, "shell", "/bin/bash", "path to shell interpreter")
	fs.StringVar(&c.scriptFile, "script_file", "", "path to runner script")
	fs.StringVar(&c.scriptArgs, "script_args", "", "optional script arguments")
	fs.StringVar(&c.importsFile, "imports_file", "", "path to the imports.csv file")
	fs.StringVar(&c.sourceIndexFile, "source_index_file", "", "path to the source_index file")
	fs.StringVar(&c.buildEventsFile, "build_events_json_file", "", "path to the build_events json file")
	fs.StringVar(&c.buildozerScriptFile, "buildozer_file", "", "path to the buildozer config path")
	fs.StringVar(&c.resolveHintFile, "hint_file", "", "path to the hint file")
	fs.StringVar(&c.symbolMappingsFile, "symbol_mappings_file", "", `path to the symbols mappings json file (e.g {"com.foo": "com.foo.Bar"})`)
	fs.StringVar(&c.labelMappingsFile, "label_mappings_file", "", `path to the labels mappings json file (e.g {"//com/foo:app": "//com/foo:scala"})`)
	fs.IntVar(&c.iterations, "iterations", 0, "number of iterations to perform.  0 (the default) means 'mo limit'")

	return c
}

func (c *config) validate() error {
	if c.scriptFile == "" {
		return fmt.Errorf("-script_file is required")
	}
	if c.buildEventsFile == "" {
		return fmt.Errorf("-build_events_json_file is required")
	}
	if c.importsFile == "" {
		return fmt.Errorf("-imports_file is required")
	}
	if c.sourceIndexFile == "" {
		return fmt.Errorf("-source_index_file is required")
	}
	if c.buildozerScriptFile == "" {
		return fmt.Errorf("-buildozer_file is required")
	}

	if err := c.readImports(); err != nil {
		return err
	}

	if err := c.readBuildozerCommandFile(); err != nil {
		return err
	}

	if err := c.readScalaRuleIndexSpec(c.sourceIndexFile); err != nil {
		return err
	}

	if c.symbolMappingsFile != "" {
		if err := readJSONStringMap(c.symbolMappingsFile, c.symbolMappings); err != nil {
			return fmt.Errorf("%v: %w", c.symbolMappingsFile, err)
		}
	}

	if c.resolveHintFile != "" {
		raw := make(map[string]string)
		if err := readJSONStringMap(c.resolveHintFile, raw); err != nil {
			return fmt.Errorf("%v: %w", c.resolveHintFile, err)
		}
		for k, v := range raw {
			fields := strings.SplitN(k, ":", 2)
			if len(fields) != 2 {
				return fmt.Errorf("%s: bad hint key (want FILENAME:SYMBOL), got %q", c.resolveHintFile, k)
			}
			filename := fields[0]
			c.hintMap[filename] = append(c.hintMap[filename], &resolveHint{
				symbol: fields[1],
				actual: v,
			})
		}
	}

	if c.labelMappingsFile != "" {
		raw := make(map[string]string)
		if err := readJSONStringMap(c.labelMappingsFile, raw); err != nil {
			return fmt.Errorf("%v: %w", c.labelMappingsFile, err)
		}
		for k, v := range raw {
			from, err := label.Parse(k)
			if err != nil {
				return err
			}
			to, err := label.Parse(v)
			if err != nil {
				return err
			}
			c.labelMappings[from] = to
		}
	}

	return nil
}

func (c *config) readScalaRuleIndexSpec(filename string) error {
	index, err := index.ReadScalaRuleIndexSpec(filename)
	if err != nil {
		return fmt.Errorf("error while reading index specification file %s: %v", filename, err)
	}

	for _, rule := range index.Rules {
		if err := c.readScalaRuleSpec(rule); err != nil {
			return err
		}
	}

	return nil
}

func (c *config) readScalaRuleSpec(rule *index.ScalaRuleSpec) error {
	ruleLabel, err := label.Parse(rule.Label)
	if err != nil || ruleLabel == label.NoLabel {
		return fmt.Errorf("bad label while loading rule %q: %v", rule.Label, err)
	}

	for _, file := range rule.Srcs {
		if err := c.readScalaFileSpec(rule, ruleLabel, file); err != nil {
			return err
		}
	}

	return nil
}

func (c *config) readScalaFileSpec(rule *index.ScalaRuleSpec, ruleLabel label.Label, file *index.ScalaFileSpec) error {
	if _, exists := c.files[file.Filename]; exists {
		return fmt.Errorf("duplicate filename <%s>", file.Filename)
	}

	c.files[file.Filename] = file

	return nil
}

func (c *config) readBuildozerCommandFile() error {
	f, err := os.Open(c.buildozerScriptFile)
	if err != nil {
		return err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}
		if strings.HasPrefix(line, "#") {
			continue
		}
		c.buildozerCommands = append(c.buildozerCommands, line)
	}
	if err := scanner.Err(); err != nil {
		return err
	}

	return nil
}

func (c *config) writeBuildozerCommandFile(newCommands []string) error {
	c.buildozerCommands = append(c.buildozerCommands, newCommands...)
	lines := strings.Join(c.buildozerCommands, "\n")
	return ioutil.WriteFile(c.buildozerScriptFile, []byte(lines), os.ModePerm)
}

func (c *config) readImports() error {
	f, err := os.Open(c.importsFile)
	if err != nil {
		return err
	}
	defer f.Close()

	csvReader := csv.NewReader(f)
	records, err := csvReader.ReadAll()
	if err != nil {
		return err
	}

	for _, record := range records {
		from, err := label.Parse(record[1])
		if err != nil {
			return fmt.Errorf("bad label:", record)
		}
		c.imports[record[0]] = from
	}

	return nil
}

func readJSONStringMap(filename string, mappings map[string]string) error {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return err
	}
	if err := json.Unmarshal(data, &mappings); err != nil {
		return err
	}
	return nil
}

type resolveHint struct {
	symbol string
	actual string
}

type State struct {
	Commands map[string]string
}
