package provider

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/rule"

	sppb "github.com/stackb/scala-gazelle/build/stack/gazelle/scala/parse"
	"github.com/stackb/scala-gazelle/pkg/resolver"
	"github.com/stackb/scala-gazelle/pkg/scalaparse"
)

// NewScalaSourceProvider constructs a new NewScalaSourceProvider.
func NewScalaSourceProvider() *ScalaSourceProvider {
	return &ScalaSourceProvider{
		parser:     scalaparse.NewScalaParseServer(),
		byFilename: make(map[string]*sppb.File),
		byRule:     make(map[label.Label]*sppb.Rule),
	}
}

// ScalaSourceProvider is provider for scala source files. If
// -scala_source_index_in is configured, the given source index will be used to
// bootstrap the internal cache.  At runtime the .ParseScalaFiles function can
// be used to parse scala files.  If the cache already has an entry for the
// filename with matching sha256, the cache hit will be used.
type ScalaSourceProvider struct {
	// importRegistry is the interface we provide imports to
	importRegistry resolver.KnownImportRegistry
	// byFilename is a mapping of the scala file to the spec
	byFilename map[string]*sppb.File
	// byRule is a mapping of the scala rule to the spec
	byRule map[label.Label]*sppb.Rule
	// parser is an instance of the scala source parser
	parser *scalaparse.ScalaParseServer
}

// Name implements part of the resolver.KnownImportProvider interface.
func (r *ScalaSourceProvider) Name() string {
	return "scala"
}

// RegisterFlags implements part of the resolver.KnownImportProvider interface.
func (r *ScalaSourceProvider) RegisterFlags(flags *flag.FlagSet, cmd string, c *config.Config) {
}

// CheckFlags implements part of the resolver.KnownImportProvider interface.
func (r *ScalaSourceProvider) CheckFlags(flags *flag.FlagSet, c *config.Config, importRegistry resolver.KnownImportRegistry) error {
	r.importRegistry = importRegistry
	return nil
}

// OnResolve implements part of the resolver.KnownImportProvider interface.
func (r *ScalaSourceProvider) OnResolve() {
	r.parser.Stop()
}

// CanProvide implements the resolver.KnownImportProvider interface.
func (cr *ScalaSourceProvider) CanProvide(from label.Label, ruleIndex func(from label.Label) (*rule.Rule, bool)) bool {
	// if the label points to a rule that was generated by this extension
	if _, ok := ruleIndex(from); ok {
		return true
	}
	return false
}

// Start begins the parser process.
func (r *ScalaSourceProvider) Start() error {
	if err := r.parser.Start(); err != nil {
		return fmt.Errorf("starting parser: %w", err)
	}
	return nil
}

// ParseScalaFiles implements scalaparse.ScalaParser
func (r *ScalaSourceProvider) ParseScalaFiles(from label.Label, kind string, dir string, srcs ...string) (*sppb.Rule, error) {
	rule := &sppb.Rule{
		Label: from.String(),
		Kind:  kind,
		Files: make([]*sppb.File, len(srcs)),
	}
	for i, src := range srcs {
		filename := filepath.Join(from.Pkg, src)
		file, err := r.parseScalaFile(dir, filename)
		if err != nil {
			return nil, err
		}
		rule.Files[i] = file
	}
	if err := r.ProvideRule(rule); err != nil {
		return nil, err
	}
	return rule, nil
}

func (r *ScalaSourceProvider) parseScalaFile(dir, filename string) (*sppb.File, error) {
	if filename == "" {
		return nil, fmt.Errorf("invalid filename argument: must not be empty")
	}
	t1 := time.Now()

	abs := filepath.Join(dir, filename)
	sha256, err := fileSha256(abs)
	if err != nil {
		return nil, fmt.Errorf("parse scala file (dir=%q, filename=%q) read sha256 error: %v", dir, filename, err)
	}

	file, ok := r.byFilename[filename]
	if ok && file.Sha256 == sha256 {
		// log.Printf("file cache hit: <%s> (%s)", filename, sha256)
		return file, nil
	}

	response, err := r.parser.Parse(context.Background(), &sppb.ParseRequest{
		Filenames: []string{abs},
	})
	if err != nil {
		return nil, fmt.Errorf("scala file parse error %s: %v", abs, err)
	}

	t2 := time.Since(t1).Round(1 * time.Millisecond)

	if response.Error != "" {
		log.Printf("Parse Error <%s>: %s", filename, response.Error)
	} else {
		log.Printf("Parsed <%s> (%v)", filename, t2)
	}

	scalaFile := response.Files[0]
	scalaFile.Sha256 = sha256
	return scalaFile, nil
}

// ProvidedRules returns a sorted list of all known source rules.
func (r *ScalaSourceProvider) ProvidedRules() []*sppb.Rule {
	rules := make([]*sppb.Rule, 0, len(r.byRule))
	for _, r := range r.byRule {
		rules = append(rules, r)
	}
	sort.Slice(rules, func(i, j int) bool {
		a := rules[i]
		b := rules[j]
		return a.Label < b.Label
	})
	return rules
}

// ProvideRule indexes the given rule.
func (r *ScalaSourceProvider) ProvideRule(rule *sppb.Rule) error {
	from, err := label.Parse(rule.Label)
	if err != nil || from == label.NoLabel {
		return fmt.Errorf("bad label while loading rule %q: %v", rule.Label, err)
	}

	for _, file := range rule.Files {
		if err := r.provideFile(from, rule, file); err != nil {
			return err
		}
	}

	r.byRule[from] = rule

	return nil
}

func (r *ScalaSourceProvider) provideFile(from label.Label, rule *sppb.Rule, file *sppb.File) error {
	if _, exists := r.byFilename[file.Filename]; exists {
		// return fmt.Errorf("duplicate filename <%s>", file.Filename)
		return nil
	}

	for _, imp := range file.Classes {
		r.provideImport(from, imp, sppb.ImportType_CLASS)
	}
	for _, imp := range file.Objects {
		r.provideImport(from, imp, sppb.ImportType_OBJECT)
	}
	for _, imp := range file.Traits {
		r.provideImport(from, imp, sppb.ImportType_TRAIT)
	}
	for _, imp := range file.Types {
		r.provideImport(from, imp, sppb.ImportType_TYPE)
	}
	for _, imp := range file.Vals {
		r.provideImport(from, imp, sppb.ImportType_VALUE)
	}
	for _, imp := range file.Packages {
		r.provideImport(from, imp, sppb.ImportType_PACKAGE)
	}

	r.byFilename[file.Filename] = file
	// log.Printf("cached file <%s> (%s) %+v", file.Filename, file.Sha256, file)

	return nil
}

func (r *ScalaSourceProvider) provideImport(from label.Label, imp string, impType sppb.ImportType) {
	r.importRegistry.PutKnownImport(&resolver.KnownImport{
		Type:   impType,
		Import: imp,
		Label:  from,
	})
}

// fileSha256 computes the sha256 hash of a file
func fileSha256(filename string) (string, error) {
	f, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer f.Close()

	return readSha256(f)
}

// Compute the sha256 hash of a reader
func readSha256(in io.Reader) (string, error) {
	h := sha256.New()
	if _, err := io.Copy(h, in); err != nil {
		return "", err
	}
	return hex.EncodeToString(h.Sum(nil)), nil
}

// func isTestRule(kind string) bool {
// 	return strings.Contains(kind, "test")
// }

// func (r *ScalaSourceProvider) providePackage(rule *sppb.Rule, ruleLabel label.Label, file *sppb.File, imp string) {
// 	if pp, ok := r.packages[imp]; ok {
// 		p := pp[0]
// 		// if there is an existing provider of the same package for the same rule, that is OK.
// 		if p.label == ruleLabel {
// 			return
// 		}
// 		// if there is an existing provider of the same package for a different
// 		// rule, non-test rules take precedence.  If two tests try and provide
// 		// the same package, the first one wins.
// 		if isTestRule(rule.Kind) {
// 			return
// 		}
// 	}
// 	r.packages[imp] = append(r.packages[imp], &providerSpec{rule, file, ruleLabel})
// }

// Provided implements the protoc.ImportProvider interface.
// func (r *ScalaSourceProvider) Provided(lang, impLang string) map[label.Label][]string {
// 	if lang != "scala" && impLang != "scala" {
// 		return nil
// 	}

// 	result := make(map[label.Label][]string)
// 	for imp, pp := range r.providers {
// 		for _, p := range pp {
// 			result[p.label] = append(result[p.label], imp)
// 		}
// 	}

// 	return result
// }
